

事务的概念简单来说就是一个原子操作， 要么操作中的几个操作全部执行， 要么全部不执行

事务的传播性：
	默认情况下的属性是REQUIRES；如果一个事务方法A，依次包含事务方法B和事务方法C，那么默认情况下当执行A的时候，
	B和C就会在A的事务中运行， 假设运行到C的时候出现异常，进行回滚，这个事务A都会回滚，B进行的操作就会无效。  
	如果希望B操作依然是有效的，那就给B配置REQUIRES_NEW属性，即在A中也会开辟新事务，这样当C出错的时候，
	B的操作依然有效，因为它在执行到C之前已经提交了。  当然如果B和C调换一下，先执行C，那么给B设置这个属性，
	B中操作也是无效的，因为C已经出错了。

5.其他属性

	指定事务的隔离级别：isolation属性，指定隔离的级别，不同级别解决相应的问题，针对之前提到的重复读，脏读等问题。

	超时回滚：timeout属性   指定事务一段时间内未执行完，强制回滚。

	readonly属性：如果方法内都是只读的操作，数据库可以对其进行优化。
	
6.Spring默认情况下会对unchecked异常(RuntimeException--运行时异常)和error进行回滚，而对checked异常(编译器可以发现的，
	可以用try catch进行捕获的)不做回滚。想让其进行回滚的话 
	1)在try catch中抛出一个自定义的运行时异常  
	2)配置checked异常时也进行回滚，@Transactional(rollbackFor=Exception.class)
	
	
	事务的配置
		当在使用注解的时候，一般都是指定rollbackFor=Exception.class，或者在配置aop:config时候，也是使用rollback-for="Exception"，
		我很不理解。 当我们不指定回滚类型的时候，默认的是对unchecked异常+error进行回滚，现在我们指定了为Exception
		(checded异常+unchecked异常，那error哪里去了)，难道我们不应该指定rollback-for="Throwable"吗。

		个人以为正确的答案是：

		[java] view plain copy
		@Transactional(rollbackFor=Throwable.class)  
		或者：
		[java] view plain copy
		<tx:method name="insert*" propagation="REQUIRED" rollback-for="Throwable"/>  
	
	
	
	
	
	
	

ACID  （原子性， 一致性， 隔离性， 持久性）
	
	隔离性
		脏读：  	事务A和B , A读取了B未提交的数据
		不可重复读：事务A和B， A负责读取， B负责写入， A连续读的过程中B写入了一次， A前后两次读取读取的数据不一样
		丢失更新：	事务A和B，A B均写入数据，A写入的数据被B覆盖
		幻读		事务A和B，A修改表内数据的过程中，B向表内插入了一条数据，A修改完后发现数据并没有被全部修改完
		
针对这以上四种问题，产生了以下四种隔离级别（其实可以算是3种，第一种并没有处理以上问题）
在说隔离级别之前先简单介绍下实现隔离级别的两种锁模式：共享锁和排他锁，这两种锁都是悲观锁，共享锁也叫S锁，是一种读锁，
当一个事物获得了一条数据的共享锁，其它事务也能获得该共享锁，但不能获得排他锁，表明其它事务可读，但不可写。
排他锁也叫X锁，是一种写锁，当一个事务对临界区加上排他锁，其它事务就不能获得该临界区的任何锁（共享锁，排他锁）。
总结一下就是共享锁保证大家可以一起读，但只能一个人写，排他锁保证只能一个人去处理数据，其他人不能读也不能写。


1.read uncommitted(未提交读)
2.read conmmitted(提交读)
3.reapetable read(可重复读)
4.serializable (序列化)

1.read uncommitted(未提交读)：其实我觉得翻译成未提交读很不好，应该根据字面理解翻译成在当前隔离级别下，会读取到
	没有提交的数据会好得多，在这种模式下，对比4种问题就会发现1-4的问题均解决不了，但这种模式也不是说完全没加锁，
	在读取时是不会加锁的，但在更新数据时，对其加行级共享锁（其它事务不能更改，但可以读取，导致脏读），事务结束时释放。
	这种隔离级别未处理任何以上4个问题。

	举例说明：
		事务A读取某行记录时，事务B也能对这行记录读取更新，当事务B更新记录时，事务A读取到事务B修改的版本，即使事务B未提交。
		事务A和B不能同时更新（共享锁保证A获取共享锁时A能读写数据，B能获取共享锁能读，不能写）

2.read conmmitted(提交读)：还是说下我的理解翻译：这种隔离级别表示读取的数据是已提交成功的，解决了脏读问题，解决方式
	是给写数据加行级排他锁，这样写过程是无法读取的，直到事务处理完毕才释放排他锁，给读的数据加行级共享锁，这样读的时候
	也是无法写的，但是一旦读完该行就释放共享锁。这种模式下虽然处理了脏读，但是并没有处理丢失更新和不可重复读的问题。

	举例说明：
		事务A负责读，事务B负责写，A读完数据后释放共享锁，B更新数据，事务还未结束，A再读，两次得到数据不一样，产生不可重复读的问题。
		同理，事务A获取共享锁，更新数据，然后释放共享锁，B此时获得排他锁，再更新数据，A的数据就可能被覆盖，产生更新丢失的问题。

3.reapetable read(可重复读)：理解翻译：在这种隔离级别下可以重复的读取数据了，顾名思义，解决了不可重复读的问题，
	同时也解决了更新丢失的问题。解决办法：给写的数据加行级排他锁，事务结束释放，给读的数据加行级共享锁，事务结束后释放。
	这种模式还是没有处理幻读的问题

	举例说明：
		事务A负责读，事务B负责写，A读完数据后等事务结束才释放共享锁，B更新数据，直到事务结束，A再读，两次得到数据均为A第一次读到的数据，解决不可重复读的问题。
		事务A负责读，只为读取的数据加行级共享锁，B在A读过程中向表单中插入新数据，A没有处理到新插入的数据，产生幻读。

4.serializable (序列化)：这个没有什么理解翻译，直接看实现就好了，实现也很简单，事务读数据则加表级共享锁，
	事务写数据则加表级排他锁，幻读问题也得到了解决














