ActiveMQ（消息不丢失）
	ActiveMQ介于ZeroMQ和RabbitMQ之间。类似于ZeroMQ，它可以部署于代理模式和P2P模式。类似于RabbitMQ，它易于实现高级场景，而且只需付出低消耗。
	被誉为消息中间件的“瑞士军刀”。支持OpenWire、Stomp、AMQP v1.0、MQTT v3.1、REST、Ajax、Webservice等多种协议；
	完全支持JMS1.1和J2EE 1.4规范（事务、持久化、XA消息）；支持持久化到数据库。但是ActiveMQ不够轻巧，
	而且对于队列较多的情况支持不好，据说还有丢消息的情况。目前已经有了其下一代消息产品Apollo。
	
Apollo	（消息不丢失）
	Apache称Apollo为最快、最强健的STOMP服务器。支持STOMP、AMQP、MQTT、OpenWire协议，支持Topic、Queue、持久订阅等消费形式，支持对消息的多种处理，
	支持安全性处理，支持REST管理API。。。功能列表很长，最大的弊病就是目前市场接收度不够，所以使用的并不广泛。
	特征：
		STOMP协议支持
		AMQP协议支持
		MQTT协议支持
		OpenWire协议支持
		主题和队列
			Apollo支持三种类型的目的地，队列，主题和持久订阅。
				1.队列和主题的区别在于消息是如何传递给消费者的。一个队列将负载平衡它在连接的用户上的消息，以便只有一个用户收到消息。
				2.主题将发送给它的每条消息复制到所有连接的订户。即使没有附加订阅，队列也会保留未使用的消息，而当没有连接的订阅时，主题将丢弃消息。
				3.持久预订允许您针对即使在客户端断开连接后也会排队消息的主题创建预订。客户可以在稍后重新连接并使用源自该主题的排队消息。
				如果您要发送或订阅队列，主题或长期订阅的STOMP目的地应为前缀/queue/， /topic/或者/dsub/分别。
		浏览订阅
			队列上的普通订阅将使用消息，以便其他订阅不会获得消息的副本。如果您想以非破坏性的方式浏览队列中的所有消息，则可以创建浏览订阅。
			浏览订阅也适用于持久订阅，因为它们由队列支持。要制作浏览订阅，只需将browser:true标题添加到SUBSCRIBE框架
		主题持久订阅
			持久订阅是订阅某个主题的队列，因此即使创建持久订阅的客户端不在线，他仍然可以获得当他重新联机时发送到该主题的所有消息的副本。
			多个客户端可以订阅相同的持久订阅，并且由于它由一个队列支持，所以这些订阅者将使主题的消息在它们之间平衡。
		镜像队列
			镜像队列一旦创建，将把发送到队列的所有消息复制到同名的主题，相反，队列将收到发送到该主题的所有消息的副本。
			镜像队列可用于在一个逻辑目标上混合队列和主题行为。例如，我们假设foo 配置为镜像目标，并且您有2个订阅者foo和2个订阅者foo。
			在生产者方面，发布者可以发送队列或主题并获得相同的结果。在消费者方面，2个消费者队列foo将获得队列语义，来自队列的消息将
			在2个消费者之间进行负载平衡。关于foo主题的两位消费者将分别获得发送的每条消息的副本。您甚至可以在主题上创建持久订阅，
			然后有效地成为镜像原始队列的队列。重要的是要注意，在队列创建之前，镜像不会启动，通常情况下，您首先会向队列发送消息或订阅消息。
		可靠的消息
			Apollo支持可靠的消息传递，允许消息持续存在，以便在发生杀死代理的故障时可以恢复消息。处理持久性消息比非持久性消息具有更多数量级的开销。
			如果您的应用程序确实需要它，您应该只使用它。要让消息持久化，发送者必须将persistent:true 标题添加到SENDSTOMP帧。此外，如果您未在交易中发送消息，
			建议您也添加一个receipt 标题。一旦代理RECEIPT以与发送相关的帧进行响应，即使发生故障，也能保证代理不会丢失消息。
		消息到期
			阿波罗支持过期的旧消息。未消费的过期消息将自动从队列中删除。有两种方法可以指定邮件何时过期.
			配置到期的第一种方法是设置expires消息标题。到期时间必须指定为Unix纪元以来的毫秒数。

		消息交换
			1.由于实现消息交换的方式，Apollo可以非常有效地处理大型和小型队列。如果你有一个拥有数百万条消息的大队列，并且正在缓慢处理它们，
			那么将所有这些消息保存在内存中是没有意义的。当消费者准备好接收它们时，他们只需要加载。

			2.apollo中的队列有一个配置条目，称为consumer_buffer哪个专用于该消费者的内存量，用于将消费者需要的下一组消息预取到内存中。
			队列将异步加载消息存储中的消息，以便在消费者准备好接收消息时它们将在内存中。

			3.消费者在队列中的消费/位置的比率也将影响新排队消息的处理方式。如果没有消费者靠近放置新消息的队列的尾部，则该消息尽快被换出内存。
			如果他们的消费者靠近队列的尾部，那么这条消息会尽可能长时间保留在内存中，希望您可以避免换出然后再回来。

			4.当消息被换出内存时，它可以处于2个换出状态之一：“交换”或“交换范围”。处于“交换”状态的消息在队列维护的消息列表中仍然有一个小的参考节点。
			这个小的参考文件保存了有关该消息的一些会计信息以及如何快速从消息存储中检索消息。一旦一个队列建立了许多处于'交换'状态的相邻消息（默认为10,000），
			它将用一个范围参考节点替换内存中所有那些单独的参考节点。一旦发生这种情况，消息处于“交换范围”。
			
		消息选择器
			消息选择器允许订阅仅接收发送到目标的消息的子集。选择器的作用类似于应用于消息属性的过滤器，并且只有那些匹配传递到订阅的消息。
			选择器使用SQL 92语法定义，通常应用于消息标题; 无论JMS消息上可用的标准属性还是可以通过JMS代码添加的自定义标头。
		消息组
			消息组是对独占使用者功能提供的增强功能
				1.保证在单个队列中处理相关消息的顺序
				2.跨多个消费者处理消息的负载均衡
				3.如果JVM发生故障，则可用性/自动故障转移到其他用户
			消息组在逻辑上就像一个并行的独占使用者。而不是所有消息都发送给单个消费者，stomp message_group头用于定义消息所属的消息组。
			然后，“消息组”功能可确保将同一消息组的所有消息发送给该组的当前分配的使用者。消息组的指定消费者使用者可能会更改，
			但在所有发送给以前使用者的消息都已被查看或消费者断开连接之前可能会更改。
			解释消息组的另一种方式是它提供消费者间消息的粘性负载均衡; 其中消息组的值有点像HTTP会话ID或cookie值，消息代理的行为就像HTTP负载平衡器。
		JAAS身份验证
			保护代理的第一步是对用户进行身份验证。默认的Apollo配置使用基于文件的认证。身份验证是使用JAAS的配置文件位于实例目录下的etc/login.conf。
			JAAS配置文件可以定义多个指定的认证域。的broker元件和 virtual_host元件可被配置为针对这些域进行身份验证。
			authentication在代理级别定义的元素将用于验证代理级别的管理功能，并对任何未定义authentication元素的虚拟主机进行身份验证。
			如果要禁用虚拟主机中的身份验证，请将该enable属性设置为false。
		基于ACL的授权
		SSL / TLS支持和基于证书的认证
		REST管理API

Kafka/Jafka （消息不丢失）
	Kafka是LinkedIn于2010年12月开发并开源的一个分布式流平台，现在是Apache的顶级项目，是一个高性能跨语言分布式Publish/Subscribe消息队列系统，
	以Pull的形式消费消息。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；
	完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现复杂均衡。因为设计之初是作为日志流平台和运营消息管道平台，
	所以实现了消息顺序和海量堆积。
	Kafka自身服务与消息的生产和消费都依赖与Zookeeper，使用Scala语言开发。因为其消息的消费使用客户端Pull方式，消息可以被多个客户端消费，
	理论上消息会重复，但是不会丢失（除非消息过期）。因此比较常用的场景是作为日志传输的消息平台。
	
	
	Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。
		具有以下特性：
			1.快速持久化，可以在O(1)的系统开销下进行消息持久化；
			2.高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；
			3.完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现复杂均衡；
			4.支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，
		但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制来统一了在线和离线的消息处理，这一点也是本课题所研究系统所看重的。
		Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。
	
	
Redis （消息会丢失）
	没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理。不提供可靠发布，需自行实现
	是一个Key-Value的NoSQL数据库，开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可 
	以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。
	测试数据分为 128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，
	而如 果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于 Redis。
	
RabbitMQ（消息不丢失）
	RabbitMQ是基于Erlang语言编写的开源消息队列，通过Erlang的Actor模型实现了数据的稳定可靠传输。本身是实现AMQP的消息队列，
	因此官方推荐，如果仅仅是使用RabbitMQ的话，建议使用AMQP 0-9-1的协议。不过，因为其可扩展性，可以通过插件的形式使用STOMP、XMPP、AMQP 1.0，
	还可以通过插件使用HTTP这种非消息的传输协议。所以，RabbitMQ可以说是适应性非常强的一个消息队列中间件了。
	当然，不仅是协议支持的多，还因为它实现了代理(Broker)架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得RabbitMQ易于使用和部署，
	适宜于很多场景如路由、负载均衡或消息持久化等，用消息队列只需几行代码即可搞定。但是，这使得它的可扩展性差，速度较慢，因为中央节点增加了延迟，
	消息封装后也比较大，如需配置RabbitMQ则需要在目标机器上安装Erlang环境。
	总的来说，RabbitMQ在数据一致性、稳定性和可靠性方面比较优秀，而且直接或间接的支持多种协议，对多种语言支持良好。
	但是其性能和吞吐量差强人意，由于Erlang语言本身的限制，二次开发成本较高。
	
	特性：
		1.异步消息
			支持多种消息协议，消息队列，传送确认，灵活的路由到队列，多种交换类型。
		2。分布式部署
			部署为高可用性和吞吐量的群集 ; 跨多个可用区域和区域进行联合。
		3.企业和云就绪
			可插入的身份验证，授权，支持TLS和LDAP。公共和私有云中轻量级且易于部署。
		4.工具和插件
			多种工具和插件支持持续集成，运营指标以及与其他企业系统的集成。用于扩展RabbitMQ功能的灵活插件方法。
		5.管理和监控
			HTTP-API，命令行工具和用于管理和监视 RabbitMQ的UI 。

	
ZeroMQ （消息会丢失）
	ZeroMQ号称是“史上最快的消息队列”，基于c语言开发的，可以在任何平台通过任何代码连接，
	通过inproc、IPC、TCP、TIPC、多播传送消息，支持发布-订阅、推-拉、共享队列等模式，高速异步I/O引擎。
	根据官方的说法，ZeroMQ是一个简单好用的传输层，像框架一样的可嵌入的socket类库，使Socket编程更加简单、简洁、性能更高，
	是专门为高吞吐量/低延迟的场景开发的。ZeroMQ与其他MQ有着本质的区别，它根本不是消息队列服务器，更类似与一个底层网络通讯库，
	对原有Socket API进行封装，在使用的使用引入对应的jar包即可，可谓是相当灵活。
	同时，因为它的简单灵活，如果我们想作为消息队列使用的话，需要开发大量代码。而且，ZeroMQ不支持消息持久化，
	其定位并不是安全可靠的消息传输，所以还需要自己编码保证可靠性。简而言之一句话，ZeroMQ很强大，但是想用好需要自己实现。
	
	特性：
		1.在任何平台上以任何语言连接您的代码。
		2.通过inproc，IPC，TCP，TIPC，多播传送消息。
		3.智能模式，如pub-sub，push-pull和router-dealer。
		4.高速异步I/O引擎，在一个小型库中。
		5.由一个庞大而活跃的开源社区支持。
		6.支持每一种现代语言和平台。
		7.构建任何架构：集中式，分布式，小型或大型。
		8.提供全面商业支持的免费软件。
	
阿里云 RocketMQ（不丢消息）
	RocketMQ是阿里开源的消息中间件，目前在Apache孵化，使用纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，
	但并不是简单的复制，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景，
	支撑了阿里多次双十一活动。因为是阿里内部从实践到产品的产物，因此里面很多接口、api并不是很普遍适用。其可靠性毋庸置疑，而且与Kafka一脉相承（甚至更优），
	性能强劲，支持海量堆积。不过，没有在mq核心上实现JMS。
	
	特性：
		1.专业
			消息领域业内专业的消息中间件，产品历史超过 9 年，消息保证不丢，技术体系丰富成熟。
			阿里内部产品名 MetaQ、Notify；开源社区产品名为 RocketMQ；产品多次在国内外获奖。
			阿里内部 1000+ 核心应用使用，每天流转几千亿条消息，经过双11交易、商品等核心链路真实场景的验证，稳定可靠。
		2.高可靠
			一份消息多份落盘存储，经过严格的断电测试，消息依然保证不丢失。
			允许海量消息堆积，单个 Topic 可堆积 100亿+条消息，系统高流量压力下依然可靠。
			默认消息持久化存储 3 天，支持重置消费位点消费3天之内任何时间点的消息。
		3.高性能
			同一网络内，消息传输网络时延在 10 毫秒之内，性能测试下，网卡可被打满。
			默认单 Topic 发送消息上限为每秒 5000 条，最高可申请扩展至 10W 以上。
			默认单条消息大小最大支持 256KB，华北2 地域支持 4MB 大消息。
		4.多协议接入
			支持 HTTP 协议：支持 RESTful 风格 HTTP 协议完成收发消息，可以解决跨语言使用 MQ 问题。
			支持 MQTT 协议：支持主动推送模型，多级 Topic 模型支持一次触达1000万+ 终端，可广泛应用于物联网和社交即时通信场景。
			支持 TCP 协议：区别于 HTTP 简单的接入方式，提供更为专业、可靠、稳定的 TCP 协议的 SDK 接入。
		5.独立部署
			支持专有云独立输出，支持物理机和虚拟机，仅几台机器便可搭建完整消息云服务。
			专有云配套 mqadmin 命令集和管理类 Open API，方便运维人员实时监控系统状态。
			支持混合云架构，允许用户通过专线的方式接入服务。

腾讯消息队列 CMQ（不丢消息）

	特性：
		1.消息队列模型
			消息推拉模式：PULL 模式
		2.功能
			丰富的队列功能
			CMQ 提供了丰富的队列属性配置选项，您可以个性化配置队列属性来满足不同的应用场景，支持多次消费、批量发送消费、重试策略配置等。
		3.支持并发访问
			支持多个生产者和消费者并发访问同一个队列，无需特殊设置即可自由调整并发度，并能确保某条消息在取出之后的特定时间段内，无法被其他消费者获得。
		4.消息并发发送及接收
			支持批量并发发送和接收消息，提升业务的吞吐性能。
		5.消息投递保障
			在消息有效期内，确保消息至少能被成功消费一次。用户间资源隔离，确保您队列中的消息不会被非法获取。
		6.支持多次消费
			若应用程序在处理消息的过程中由于断电等原因处理失败，可多次重试。
		7.消息主题模型
			消息推拉模式：PUSH 模式
	功能：
		1.一对多消息投递
			一条通知消息可以同时被多个订阅者订阅和消费，支持将某 Queue 设为订阅者。
		2.多种投递方式
			支持 HTTP/HTTPS 等多种投递方式。
		3.消息过滤
			可根据消息 TAG、订阅者 TAG 进行消费过滤，增加消费灵活性。
		4.消息投递保障
			在消息有效期内，保证发布到 Topic 中的消息会按照指定的重试策略，进行多次重试投递，尽可能保证业务成功接收消息。
	
总结：	
	ActiveMQ目前在社区已经不是很活跃，但下一代产品Apollo已经问世。ZeroMQ小而美，
	RabbitMQ大而稳，Kakfa和RocketMQ快而强劲。RocketMQ虽然目前还很多不完善，但是一旦在Apache孵化成为顶级项目。
	



