ActiveMQ
	ActiveMQ介于ZeroMQ和RabbitMQ之间。类似于ZeroMQ，它可以部署于代理模式和P2P模式。类似于RabbitMQ，它易于实现高级场景，而且只需付出低消耗。
	被誉为消息中间件的“瑞士军刀”。支持OpenWire、Stomp、AMQP v1.0、MQTT v3.1、REST、Ajax、Webservice等多种协议；
	完全支持JMS1.1和J2EE 1.4规范（事务、持久化、XA消息）；支持持久化到数据库。但是ActiveMQ不够轻巧，
	而且对于队列较多的情况支持不好，据说还有丢消息的情况。目前已经有了其下一代消息产品Apollo。
	
Apollo	
	Apache称Apollo为最快、最强健的STOMP服务器。支持STOMP、AMQP、MQTT、OpenWire协议，支持Topic、Queue、持久订阅等消费形式，支持对消息的多种处理，
	支持安全性处理，支持REST管理API。。。功能列表很长，最大的弊病就是目前市场接收度不够，所以使用的并不广泛。
		

Kafka
	Kafka是LinkedIn于2010年12月开发并开源的一个分布式流平台，现在是Apache的顶级项目，是一个高性能跨语言分布式Publish/Subscribe消息队列系统，
	以Pull的形式消费消息。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；
	完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现复杂均衡。因为设计之初是作为日志流平台和运营消息管道平台，
	所以实现了消息顺序和海量堆积。
	Kafka自身服务与消息的生产和消费都依赖与Zookeeper，使用Scala语言开发。因为其消息的消费使用客户端Pull方式，消息可以被多个客户端消费，
	理论上消息会重复，但是不会丢失（除非消息过期）。因此比较常用的场景是作为日志传输的消息平台。
	
	
Redis
	没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理。不提供可靠发布，需自行实现
	
RabbitMQ
	RabbitMQ是基于Erlang语言编写的开源消息队列，通过Erlang的Actor模型实现了数据的稳定可靠传输。本身是实现AMQP的消息队列，
	因此官方推荐，如果仅仅是使用RabbitMQ的话，建议使用AMQP 0-9-1的协议。不过，因为其可扩展性，可以通过插件的形式使用STOMP、XMPP、AMQP 1.0，
	还可以通过插件使用HTTP这种非消息的传输协议。所以，RabbitMQ可以说是适应性非常强的一个消息队列中间件了。
	当然，不仅是协议支持的多，还因为它实现了代理(Broker)架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得RabbitMQ易于使用和部署，
	适宜于很多场景如路由、负载均衡或消息持久化等，用消息队列只需几行代码即可搞定。但是，这使得它的可扩展性差，速度较慢，因为中央节点增加了延迟，
	消息封装后也比较大，如需配置RabbitMQ则需要在目标机器上安装Erlang环境。
	总的来说，RabbitMQ在数据一致性、稳定性和可靠性方面比较优秀，而且直接或间接的支持多种协议，对多种语言支持良好。
	但是其性能和吞吐量差强人意，由于Erlang语言本身的限制，二次开发成本较高。

	
ZeroMQ
	ZeroMQ号称是“史上最快的消息队列”，基于c语言开发的，可以在任何平台通过任何代码连接，
	通过inproc、IPC、TCP、TIPC、多播传送消息，支持发布-订阅、推-拉、共享队列等模式，高速异步I/O引擎。
	根据官方的说法，ZeroMQ是一个简单好用的传输层，像框架一样的可嵌入的socket类库，使Socket编程更加简单、简洁、性能更高，
	是专门为高吞吐量/低延迟的场景开发的。ZeroMQ与其他MQ有着本质的区别，它根本不是消息队列服务器，更类似与一个底层网络通讯库，
	对原有Socket API进行封装，在使用的使用引入对应的jar包即可，可谓是相当灵活。
	同时，因为它的简单灵活，如果我们想作为消息队列使用的话，需要开发大量代码。而且，ZeroMQ不支持消息持久化，
	其定位并不是安全可靠的消息传输，所以还需要自己编码保证可靠性。简而言之一句话，ZeroMQ很强大，但是想用好需要自己实现。
	
阿里云 RocketMQ
	RocketMQ是阿里开源的消息中间件，目前在Apache孵化，使用纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，
	但并不是简单的复制，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景，
	支撑了阿里多次双十一活动。因为是阿里内部从实践到产品的产物，因此里面很多接口、api并不是很普遍适用。其可靠性毋庸置疑，而且与Kafka一脉相承（甚至更优），
	性能强劲，支持海量堆积。不过，没有在mq核心上实现JMS。

腾讯消息队列 CMQ
	消息队列模型
	消息推拉模式：PULL 模式
	功能
	丰富的队列功能
	CMQ 提供了丰富的队列属性配置选项，您可以个性化配置队列属性来满足不同的应用场景，支持多次消费、批量发送消费、重试策略配置等。

	支持并发访问
	支持多个生产者和消费者并发访问同一个队列，无需特殊设置即可自由调整并发度，并能确保某条消息在取出之后的特定时间段内，无法被其他消费者获得。

	消息并发发送及接收
	支持批量并发发送和接收消息，提升业务的吞吐性能。

	消息投递保障
	在消息有效期内，确保消息至少能被成功消费一次。用户间资源隔离，确保您队列中的消息不会被非法获取。

	支持多次消费
	若应用程序在处理消息的过程中由于断电等原因处理失败，可多次重试。

	消息主题模型
	消息推拉模式：PUSH 模式
	功能
	一对多消息投递
	一条通知消息可以同时被多个订阅者订阅和消费，支持将某 Queue 设为订阅者。

	多种投递方式
	支持 HTTP/HTTPS 等多种投递方式。

	消息过滤
	可根据消息 TAG、订阅者 TAG 进行消费过滤，增加消费灵活性。

	消息投递保障
	在消息有效期内，保证发布到 Topic 中的消息会按照指定的重试策略，进行多次重试投递，尽可能保证业务成功接收消息。
	
总结：	
	其实对于这些消息队列的产品，每一种都在某一领域占有一席，虽然ActiveMQ目前在社区已经不是很活跃，但是其下一代产品Apollo已经问世。ZeroMQ小而美，
	RabbitMQ大而稳，Kakfa和RocketMQ快而强劲。RocketMQ虽然目前还很多不完善，但是一旦在Apache孵化成为顶级项目，全球程序猿开始贡献，前途也是不可限量的。
	



